---
layout:     post
title:      "「GS」全基因组选择BGLR-GBLUP"
subtitle:   "使用BGLR构建贝叶斯模型"
date:       2023-11-28 12:00:00
author:     "云伴风行"
header-img: "img/blog-life4.jpg"
header-mask: 50%
catalog: true
mathjax: true
tags:
    - 全基因组选择
    - GBLUP
    - BGLR
---
> 本文使用 **[BGLR](https://github.com/gdlc/BGLR-R)** 实现全基因组选择贝叶斯模型构建  
> 本文使用R版本：R version 4.3.1

### BGLR环境搭建

```R
## ---------------------------
## Script name: BGLR_GS
## Author: hanfc
## Date Created: 2023-11-28
##
## Copyright (c) Hanfc, 2023
## Email: 2624366594@qq.com
## ---------------------------
## Notes:
##   
## ---------------------------
## load up the packages we will need:  (uncomment as required)
# 安装并加载BGLR包 --------------------------------------------------------------
# 检查是否安装BGLR包
if (!require("BGLR"))install.packages('BGLR')
library(BGLR)
if (!require("plyr"))install.packages("plyr")
library(plyr)
if (!require("sommer"))install.packages("sommer")
library(sommer)
if (!require("bigmemory"))install.packages("bigmemory")
library(bigmemory)

library(data.table)
```
### 这一步写一个函数来调用BGLR中的GBLUP模型

**参数：**

> @phe：表型名称  
> @output：输出文件路径  
> @repeats：交叉验证重复次数  
> 通过重复多次的随机划分训练数据集，能够有效减少随机性引起的方差。  
> @folds：交叉验证折数  
> 将训练数据集划分多个折数，轮流作为测试集训练模型  

函数将计算模型评估指标：

- 均方根误差(RMSE)：  

  $RMSE=\sqrt\frac{\sum^n_{i=1}(y_i-\hat{y_i})^2}{n}$

- 平均绝对误差(MAE):  

  $MAE=\frac{\sum_{i=1}^n{\|y_i-\hat{y_i}\|}}{n}$

- 相关系数(COR):  

  $COR=\frac{\sum_{i=1}^n(y_i-\overline{y_i})^2(\hat{y_i}-\overline{\hat{y}})}{\sqrt{\sum_{i=1}^n}(y_i-\overline{y}^2)\sum_{i=1}^n(\hat{y_i}-\overline{\hat{y}}^2)}$

- 均方误差(MSE):  

  $MSE=\frac{\sum_{i=1}^n(y_i-\hat{y_i}^2)}{n}$

```r
## ---------------------------
##
## @param phe: the name of phenotype
## @param output: the output path
## @param repeats: the number of model repetitions
## @param folds: the number of cross-valitations
## 
## @return
## Output: 
##
## ---------------------------
## Notes:
##   
## ---------------------------

gblup_model <- function(nIter, burnIn, G, phe, train_phe, output, repeats, folds){
  # the begin
  cat("#--------------------------------------#\n")
  cat("#          BGLR: GBLUP model           #\n")
  cat("#--------------------------------------#\n")
  #
  # 参数设置：(5:1 7:2 8:3)
  nIter <- nIter
  burnIn <- burnIn
  
  # cross validation
  folds <- folds
  repeats <- repeats
  
  y <- train_phe[, c(1)]
  n <- length(y)
  
  # 存储所有重复的结果
  all_results <- list()
  
  for (rep in 1:repeats) {
    # 设置随机种子
    set.seed(rep + 2023)
    # 在每次循环前重新生成sets
    sets <- rep(1:10, round(n / folds, digits = 0))
    sets <- sets[order(runif(nrow(train_geno)))]
    
    # 初始化评价指标
    # 相关性
    COR.CV <- rep(NA, times = (folds + 1))
    # 均方误差
    MSE.CV <- rep(NA, times = (folds + 1))
    # 平均绝对误差
    MAE.CV <- rep(NA, times = (folds + 1))
    # 均方根误差
    RMSE.CV <- rep(NA, times = (folds + 1))
    # 交叉验证结果
    yHatCV <- numeric()
    # 每一折的结果
    result_list <- list()
    
    for (fold in 1:folds) {
      yNa <- y
      whichNa <- which(sets == fold)
      yNa[whichNa] <- NA
      ETA <- list(list(K = G, model = 'RKHS'))
      fm <- BGLR(y = yNa,
                 ETA = ETA,
                 nIter = nIter,
                 burnIn = burnIn,
                 saveAt = paste0(output,"/", phe, '_RKHS_', rep, '_', fold, '_'))
      yHatCV[whichNa] <- fm$yHat[whichNa]
      COR.CV[fold] <- cor(fm$yHat[whichNa], y[whichNa])
      MAE.CV[fold] <- mean(abs(fm$yHat[whichNa] - y[whichNa]))
      MSE.CV[fold] <- mean((fm$yHat[whichNa] - y[whichNa])^2)
      RMSE.CV[fold] <- sqrt(mean((fm$yHat[whichNa] - y[whichNa])^2))
      
      # 将每一折的结果存储到结果列表中
      result_list[[fold]] <- list(
        COR = COR.CV[fold],
        MAE = MAE.CV[fold],
        MSE = MSE.CV[fold],
        RMSE = RMSE.CV[fold],
        real_value = y[whichNa],
        pred_value = fm$yHat[whichNa]
      )
    }
    
    # 将当前重复的结果存储到列表中
    all_results[[rep]] <- result_list
  }
  
  combined_data <- data.frame()
  for (rep in 1:repeats){
    
    for (fold in 1:folds) {
      # 提取嵌套列表中的观测值
      real_value <- all_results[[rep]][[fold]]$real_value
      # 提取嵌套列表中的预测值
      pred_value <- all_results[[rep]][[fold]]$pred_value
      
      rep_fold_data <- data.frame(
        Rep = rep,
        Fold = fold,
        RealValue = real_value,
        PredValue = pred_value
      )
      combined_data <- rbind(combined_data, rep_fold_data)
    }
  }
  return(combined_data)
}

```

